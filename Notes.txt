* Better to write the namespace with :: as we may not use single namespace throughout a program. 
*  Overflow: 
    char x = 127;
    std::cout << (int)x << std::endl; // prints 127
    x++;
    std::cout << (int)x << std::endl; // prints -128

* Dynamic decleration of variables allows you to use variables wherever they needed. 
    This improves efficiency as the declared variable will be removed after its scope ends. 
    You can define a variable inside an if statement, just like you do in for loops. 

* In switch case statement, a fall-thru means executing next case in the absence of a break. 
    int and char are the allowed data types in cases. 
    In else if ladder, multiple conditions are checked. 
        in switch case it will directly jump to the case statement. So switch is faster than else if ladder

* For loop is used when the number of iterations are known in advance. 

* The declared variables are allocated in stack. When you declare a pointer and allocate space using new, it is allocated from heap. 
    You need to delete the allocated memory from heap yourself. 
    Otherwise it will be kept until as long as program is running. 
    Stack varia are deleted automotically. 

* Some problems when using pointers: 
    - Uninitilized pointer
    - Memory leak
    - Dangling pointer

    Java and .NET deals with such issues. CPP doesn't. This is more powerfull. But you need to be careful. 

* Reference: 
    It is like creating an alias. The same memory location is used. 
    x = 10; 
    int &y = x; // y can be used instead of x afterwards
    // if you print &x and &y, they are the same
    // once the reference is defined, it cannot be reinitialized for another variable:
    //  for example, &y = z; is not possible as we first assigned x to y. 
    // int &y; is also invalid, as decleration of a reference is not possible without initialization

* size of a pointer is independent of its data type. int *p1; or float *p2; or char *p3; all takes 8 bytes in latest compilers. 
    (assuming that pointer takes 2 bytes to make explanation simple)

* int x=10; int *y=&x; int * &z=y; // x is a variable. y is a pointer variable, pointing to x. z is a reference to a pointer variable. 
    // int *&z=y; means z is another name of y. now y and z are 2 names of same pointer.   