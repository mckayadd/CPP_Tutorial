* Better to write the namespace with :: as we may not use single namespace throughout a program. 
*  Overflow: 
    char x = 127;
    std::cout << (int)x << std::endl; // prints 127
    x++;
    std::cout << (int)x << std::endl; // prints -128

* Dynamic decleration of variables allows you to use variables wherever they needed. 
    This improves efficiency as the declared variable will be removed after its scope ends. 
    You can define a variable inside an if statement, just like you do in for loops. 

* In switch case statement, a fall-thru means executing next case in the absence of a break. 
    int and char are the allowed data types in cases. 
    In else if ladder, multiple conditions are checked. 
        in switch case it will directly jump to the case statement. So switch is faster than else if ladder

* For loop is used when the number of iterations are known in advance. 

* The declared variables are allocated in stack. When you declare a pointer and allocate space using new, it is allocated from heap. 
    You need to delete the allocated memory from heap yourself. 
    Otherwise it will be kept until as long as program is running. 
    Stack varia are deleted automotically. 

* Some problems when using pointers: 
    - Uninitilized pointer
    - Memory leak
    - Dangling pointer

    Java and .NET deals with such issues. CPP doesn't. This is more powerfull. But you need to be careful. 

* Reference: 
    It is like creating an alias. The same memory location is used. 
    x = 10; 
    int &y = x; // y can be used instead of x afterwards
    // if you print &x and &y, they are the same
    // once the reference is defined, it cannot be reinitialized for another variable:
    //  for example, &y = z; is not possible as we first assigned x to y. 
    // int &y; is also invalid, as decleration of a reference is not possible without initialization

* size of a pointer is independent of its data type. int *p1; or float *p2; or char *p3; all takes 8 bytes in latest compilers. 
    (assuming that pointer takes 2 bytes to make explanation simple)

* int x=10; int *y=&x; int * &z=y; // x is a variable. y is a pointer variable, pointing to x. z is a reference to a pointer variable. 
    // int *&z=y; means z is another name of y. now y and z are 2 names of same pointer.  

*  int x = 9;  // Global variable

int main() {
    int x = 10;  // Local variable inside main()

    cout << x + ::x;  // Using `::x` to refer to the global variable
}

* Thinking in modular programming vs. OOP: modular you think as the functions. In objects, objects have functions and data related to those functions. 

* Principles of OOP:
    - Abstraction
    - Encapsulation
        .Data Hiding
    - Inheritance
    - Polymorphism

* Abstraction: About a class, I only know the functions of it. 
    I only know the name of it, no idea how it works (until I need to go into the implementation details.)
    We use printf, but we don't know the implementation of it
    (of course it can be written by every programmer but you usually don't need it)

* Encapsulation: Data is encapsulated, functions are visible. 
    It is for avoiding mishandling. Unintentional changes. It has nothing to do with security. 
    Data is private, functions are public. 

* Inheritance: a class inherites features from the parent and can have more... 

* Polymorphism: allows a single interface to represent multiple forms of behaviors. 
    Function overloading and method overriding are allowed by polymorphism.

 
